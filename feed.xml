<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-04-05T20:55:22Z</updated>

    
    <entry>
        <title>Announcing Rust 1.33.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html" type="text/html" title="Announcing Rust 1.33.0" />
        <published>2019-02-28T00:00:00Z</published>
        <updated>2019-02-28T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.33.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.33.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes for
1.33.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.33.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.33.0-stable&quot;&gt;&lt;/a&gt;What's in 1.33.0 stable&lt;/h2&gt;
&lt;p&gt;The two largest features in this release are significant improvements to
&lt;code&gt;const fn&lt;/code&gt;s, and the stabilization of a new concept: &amp;quot;pinning.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn-improvements&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt; improvements&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;const fn&lt;/code&gt;, you can &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57175/&quot;&gt;now do way more
things!&lt;/a&gt; Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;irrefutable destructuring patterns (e.g. &lt;code&gt;const fn foo((x, y): (u8, u8)) { ... }&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;mutable &lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let mut x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;assignment (e.g. &lt;code&gt;x = y&lt;/code&gt;) and assignment operator (e.g. &lt;code&gt;x += y&lt;/code&gt;)
expressions, even where the assignment target is a projection (e.g. a struct
field or index operation like &lt;code&gt;x[3] = 42&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;expression statements (e.g. &lt;code&gt;3;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You're also &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57067/&quot;&gt;able to call &lt;code&gt;const unsafe fn&lt;/code&gt;s inside a &lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const unsafe fn foo() -&amp;gt; i32 { 5 }
const fn bar() -&amp;gt; i32 {
    unsafe { foo() }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these additions, many more functions in the standard library are able to
be marked as &lt;code&gt;const&lt;/code&gt;. We'll enumerate those in the library section below.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#pinning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;pinning&quot;&gt;&lt;/a&gt;Pinning&lt;/h3&gt;
&lt;p&gt;This release introduces a new concept for Rust programs, implemented as two
types: the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;std::pin::Pin&amp;lt;P&amp;gt;&lt;/code&gt;
type&lt;/a&gt;, and the &lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;
marker trait&lt;/a&gt;. The core
idea is elaborated on in &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot;&gt;the docs for
&lt;code&gt;std::pin&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is sometimes useful to have objects that are guaranteed to not move, in
the sense that their placement in memory does not change, and can thus be
relied upon. A prime example of such a scenario would be building
self-referential structs, since moving an object with pointers to itself will
invalidate them, which could cause undefined behavior.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location
in memory, meaning it cannot be moved elsewhere and its memory cannot be
deallocated until it gets dropped. We say that the pointee is &amp;quot;pinned&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This feature will largely be used by library authors, and so we won't talk a
lot more about the details here. Consult the docs if you're interested in
digging into the details. However, the stabilization of this API is important
to Rust users generally because it is a significant step forward towards a
highly anticipated Rust feature: &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. We're not quite there yet,
but this stabilization brings us one step closer. You can track all of the
necessary features at &lt;a href=&quot;https://areweasyncyet.rs/&quot;&gt;areweasyncyet.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#import-as-_&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;import-as-_&quot;&gt;&lt;/a&gt;Import as &lt;code&gt;_&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56303/&quot;&gt;You can now import an item as
&lt;code&gt;_&lt;/code&gt;&lt;/a&gt;. This allows you to
import a trait's impls, and not have the name in the namespace. e.g.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::io::Read as _;

// Allowed as there is only one `Read` in the module.
pub trait Read {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;Here's all of the stuff that's been made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57566&quot;&gt;The methods &lt;code&gt;overflowing_{add, sub, mul, shl, shr}&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt;
functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;rotate_right&lt;/code&gt;, and &lt;code&gt;wrapping_{add, sub, mul, shl, shr}&lt;/code&gt;
are now &lt;code&gt;const&lt;/code&gt; functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;is_positive&lt;/code&gt; and &lt;code&gt;is_negative&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; functions for
all signed numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57167&quot;&gt;The &lt;code&gt;get&lt;/code&gt; method for all &lt;code&gt;NonZero&lt;/code&gt; types is now &lt;code&gt;const&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;The methods &lt;code&gt;count_ones&lt;/code&gt;, &lt;code&gt;count_zeros&lt;/code&gt;, &lt;code&gt;leading_zeros&lt;/code&gt;, &lt;code&gt;trailing_zeros&lt;/code&gt;,
&lt;code&gt;swap_bytes&lt;/code&gt;, &lt;code&gt;from_be&lt;/code&gt;, &lt;code&gt;from_le&lt;/code&gt;, &lt;code&gt;to_be&lt;/code&gt;, &lt;code&gt;to_le&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; for all
numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;&lt;code&gt;Ipv4Addr::new&lt;/code&gt; is now a &lt;code&gt;const&lt;/code&gt; function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at&quot;&gt;&lt;code&gt;unix::FileExt::read_exact_at&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at&quot;&gt;&lt;code&gt;unix::FileExt::write_all_at&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose&quot;&gt;&lt;code&gt;Option::transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose&quot;&gt;&lt;code&gt;Result::transpose&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/convert/fn.identity.html&quot;&gt;&lt;code&gt;convert::identity&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;pin::Pin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;marker::Unpin&lt;/code&gt;&lt;/a&gt; (mentioned above)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/marker/struct.PhantomPinned.html&quot;&gt;&lt;code&gt;marker::PhantomPinned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.resize_with&quot;&gt;&lt;code&gt;VecDeque::resize_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_millis&quot;&gt;&lt;code&gt;Duration::as_millis&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_micros&quot;&gt;&lt;code&gt;Duration::as_micros&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_nanos&quot;&gt;&lt;code&gt;Duration::as_nanos&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6484/&quot;&gt;Cargo should now rebuild a crate if a file was modified during the initial
build.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cratesio&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cratesio&quot;&gt;&lt;/a&gt;Crates.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;As previously announced&lt;/a&gt;, coinciding with this release, crates.io
will require that you have a verified email address to publish. Starting at
2019-03-01 00:00 UTC, if you don't have a verified email address and run &lt;code&gt;cargo publish&lt;/code&gt;, you'll get an error.&lt;/p&gt;
&lt;p&gt;This ensures we can comply with DMCA procedures. If you haven't heeded the
warnings cargo printed during the last release cycle, head on over to
&lt;a href=&quot;https://crates.io/me&quot;&gt;crates.io/me&lt;/a&gt; to set and verify your email address. This email address
will never be displayed publicly and will only be used for crates.io operations.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-133.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-133.0&quot;&gt;&lt;/a&gt;Contributors to 1.33.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.33.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.33.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes in the core team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html" type="text/html" title="Changes in the core team" />
        <published>2019-02-22T00:00:00Z</published>
        <updated>2019-02-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html">&lt;p&gt;Just a quick update: You may have noticed that, in the last month or
so, a number of &lt;a href=&quot;https://www.rust-lang.org/governance/teams/core&quot;&gt;Rust core team&lt;/a&gt; members have changed their jobs
and/or their roles in the project. Two people have decided to step
back from the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nick Cameron &lt;a href=&quot;https://www.ncameron.org/blog/leaving-mozilla-and-most-of-the-rust-project/&quot;&gt;left Mozilla to work at PingCap&lt;/a&gt;. Although he
won’t have time to stay active on the core team, he plans to
continue co-leading the Cargo team in his new position.&lt;/li&gt;
&lt;li&gt;Aaron Turon &lt;a href=&quot;https://internals.rust-lang.org/t/aturon-retires-from-the-core-team-but-not-from-rust/9392/3&quot;&gt;decided to step back from the core team&lt;/a&gt; so
that he could focus on engineering work and the language design
team. (He remains on the Rust team at Mozilla.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Rust 2018 having shipped, this is a natural time of
transition. While we’ll miss Nick and Aaron’s contributions to the
core team, we are very excited for them to be focusing on something
new, and we’re very happy that they are still going to stay involved
with Rust. We’re also looking into growing the core team to help with
the work ahead.&lt;/p&gt;
&lt;p&gt;Finally, two other members have changed their jobs, but plan to stay
involved in the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ashley Williams &lt;a href=&quot;https://twitter.com/ag_dubs/status/1088118810157219848&quot;&gt;joined Cloudflare and plans to work on Rust and WASM integration there&lt;/a&gt;.
She will be remaining on the core team.&lt;/li&gt;
&lt;li&gt;Steve Klabnik &lt;a href=&quot;https://words.steveklabnik.com/thank-u-next&quot;&gt;left Mozilla, but will remain on the core team.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That’s it!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.32.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html" type="text/html" title="Announcing Rust 1.32.0" />
        <published>2019-01-17T00:00:00Z</published>
        <updated>2019-01-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.32.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.32.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes for
1.32.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As a small side note, &lt;code&gt;rustup&lt;/code&gt; has seen some new releases lately! To update
&lt;code&gt;rustup&lt;/code&gt; itself, run &lt;code&gt;rustup self update&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.32.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.32.0-stable&quot;&gt;&lt;/a&gt;What's in 1.32.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.32.0 has a few quality of life improvements, switches the default
allocator, and makes additional functions &lt;code&gt;const&lt;/code&gt;. Read on for a few
highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for additional
information.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#the-dbg-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-dbg-macro&quot;&gt;&lt;/a&gt;The &lt;code&gt;dbg&lt;/code&gt; macro&lt;/h4&gt;
&lt;p&gt;First up, a quality of life improvement. Are you a &amp;quot;print debugger&amp;quot;? If you are, and
you've wanted to print out some value while working on some code, you have to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 5;

println!(&amp;quot;{:?}&amp;quot;, x);

// or maybe even this
println!(&amp;quot;{:#?}&amp;quot;, x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn't the &lt;em&gt;largest&lt;/em&gt; speed bump, but it is a lot of stuff to simply show the value of &lt;code&gt;x&lt;/code&gt;.
Additionally, there's no context here. If you have several of these &lt;code&gt;println!&lt;/code&gt;s, it can be hard
to tell which is which, unless you add your own context to each invocation, requiring even more work.&lt;/p&gt;
&lt;p&gt;In Rust 1.32.0, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56395/&quot;&gt;we've added a new macro,
&lt;code&gt;dbg!&lt;/code&gt;&lt;/a&gt;, for this purpose:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let x = 5;
    
    dbg!(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run this program, you'll see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:4] x = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You get the file and line number of where this was invoked, as well as the
name and value. Additionally, &lt;code&gt;println!&lt;/code&gt; prints to the standard output, so
you really should be using &lt;code&gt;eprintln!&lt;/code&gt; to print to standard error. &lt;code&gt;dbg!&lt;/code&gt;
does the right thing and goes to &lt;code&gt;stderr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It even works in more complex circumstances. Consider this factorial example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if n &amp;lt;= 1 {
        n
    } else {
        n * factorial(n - 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to debug this, we might write it like this with &lt;code&gt;eprintln!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    eprintln!(&amp;quot;n: {}&amp;quot;, n);

    if n &amp;lt;= 1 {
        eprintln!(&amp;quot;n &amp;lt;= 1&amp;quot;);

        n
    } else {
        let n = n * factorial(n - 1);

        eprintln!(&amp;quot;n: {}&amp;quot;, n);

        n
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to log &lt;code&gt;n&lt;/code&gt; on each iteration, as well as have some kind of context
for each of the branches. We see this output for &lt;code&gt;factorial(4)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;n: 4
n: 3
n: 2
n: 1
n &amp;lt;= 1
n: 2
n: 6
n: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is servicable, but not particularly great. Maybe we could work on how we
print out the context to make it more clear, but now we're not debugging our code,
we're figuring out how to make our debugging code better.&lt;/p&gt;
&lt;p&gt;Consider this version using &lt;code&gt;dbg!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if dbg!(n &amp;lt;= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We simply wrap each of the various expressions we want to print with the macro. We
get this output instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the &lt;code&gt;dbg!&lt;/code&gt; macro returns the value of what it's debugging, instead of
&lt;code&gt;eprintln!&lt;/code&gt; which returns &lt;code&gt;()&lt;/code&gt;, we need to make &lt;em&gt;no&lt;/em&gt; changes to the structure
of our code. Additionally, we have &lt;em&gt;vastly&lt;/em&gt; more useful output.&lt;/p&gt;
&lt;p&gt;That's a lot to say about a little macro, but we hope it improves your
debugging experience! We are contining to work on support for &lt;code&gt;gdb&lt;/code&gt; and
friends as well, of course.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#jemalloc-is-removed-by-default&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;jemalloc-is-removed-by-default&quot;&gt;&lt;/a&gt;&lt;code&gt;jemalloc&lt;/code&gt; is removed by default&lt;/h4&gt;
&lt;p&gt;Long, long ago, Rust had a large, Erlang-like runtime. We chose to use
&lt;a href=&quot;http://jemalloc.net/&quot;&gt;jemalloc&lt;/a&gt; instead of the system allocator, because it often improved
performance over the default system one. Over time, we shed more and more of
this runtime, and eventually almost all of it was removed, but jemalloc
was not. We didn't have a way to choose a custom allocator, and so we
couldn't really remove it without causing a regression for people who do need
jemalloc.&lt;/p&gt;
&lt;p&gt;Also, saying that &lt;code&gt;jemalloc&lt;/code&gt; was always the default is a bit UNIX-centric,
as it was only the default on &lt;em&gt;some&lt;/em&gt; platforms. Notably, the MSVC target on
Windows has shipped the system allocator for a long time.&lt;/p&gt;
&lt;p&gt;Finally, while jemalloc &lt;em&gt;usually&lt;/em&gt; has great performance, that's not always
the case. Additionally, it adds about 300kb to every Rust binary. We've also
had a host of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36963#issuecomment-252029017&quot;&gt;other
issues&lt;/a&gt;
with jemalloc in the past. It has also felt a little strange that a systems
language does not default to the system's allocator.&lt;/p&gt;
&lt;p&gt;For all of these reasons, once &lt;a href=&quot;https://blog.rust-lang.org/2018/08/02/Rust-1.28.html#whats-in-1.28.0-stable&quot;&gt;Rust 1.28 shipped a way to choose a global
allocator&lt;/a&gt;,
we started making plans to switch the default to the system allocator, and
allow you to use &lt;code&gt;jemalloc&lt;/code&gt; via a crate. In Rust 1.32, we've finally finished
this work, and by default, you will get the system allocator for your
programs.&lt;/p&gt;
&lt;p&gt;If you'd like to continue to use jemalloc, use &lt;a href=&quot;https://crates.io/crates/jemallocator&quot;&gt;the jemallocator crate&lt;/a&gt;. In
your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;jemallocator = &amp;quot;0.1.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in your crate root:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it! If you don't need jemalloc, it's not forced upon you, and if
you do need it, it's a few lines of code away.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#final-module-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;final-module-improvements&quot;&gt;&lt;/a&gt;Final module improvements&lt;/h4&gt;
&lt;p&gt;In the past two releases, we announced several improvements to the module
system. We have one last tweak landing in 1.32.0 and the 2018 edition.
Nicknamed &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56759#issuecomment-450051210&quot;&gt;&amp;quot;uniform
paths&amp;quot;&lt;/a&gt;,
it permits previously invalid import path statements to be resolved exactly
the same way as non-import paths. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Color { Red, Green, Blue }

use Color::*;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code did &lt;em&gt;not&lt;/em&gt; previously compile, as &lt;code&gt;use&lt;/code&gt; statements had to start with
&lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;crate&lt;/code&gt;. Now that the compiler supports uniform paths,
this code will work, and do what you probably expect: import the variants of
the &lt;code&gt;Color&lt;/code&gt; enum defined above the &lt;code&gt;use&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;With this change in place, we've completed our efforts at revising the module
system. We hope you've been enjoying the simplified system so far!&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#macro-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macro-improvements&quot;&gt;&lt;/a&gt;Macro improvements&lt;/h4&gt;
&lt;p&gt;A few improvements to macros have landed in Rust 1.32.0. First, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56072/&quot;&gt;a new
&lt;code&gt;literal&lt;/code&gt; matcher&lt;/a&gt; was added:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! m {
    ($lt:literal) =&amp;gt; {};
}

fn main() {
    m!(&amp;quot;some string literal&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;literal&lt;/code&gt; matches against literals of any type; string literals, numeric literals, &lt;code&gt;char&lt;/code&gt; literals.&lt;/p&gt;
&lt;p&gt;In the 2018 edition, &lt;code&gt;macro_rules&lt;/code&gt; macros can also use &lt;code&gt;?&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! bar {
    ($(a)?) =&amp;gt; {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;?&lt;/code&gt; will match zero or one repetitions of the pattern, similar to the
already-existing &lt;code&gt;*&lt;/code&gt; for &amp;quot;zero or more&amp;quot; and &lt;code&gt;+&lt;/code&gt; for &amp;quot;one or more.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;We talked above about the &lt;code&gt;dbg!&lt;/code&gt; macro, which is a big library addition.
Beyond that, 19 functions were made &lt;code&gt;const fn&lt;/code&gt;s, and all integral numeric
primitives now provide conversion functions to and from byte-arrays with
specified endianness. These six functions are named &lt;code&gt;to_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt; and
&lt;code&gt;from_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt;, where &lt;code&gt;&amp;lt;endian&amp;gt;&lt;/code&gt; is one of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ne&lt;/code&gt; - native endianness&lt;/li&gt;
&lt;li&gt;&lt;code&gt;le&lt;/code&gt; - little endian&lt;/li&gt;
&lt;li&gt;&lt;code&gt;be&lt;/code&gt; - big endian&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo gained &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6218/&quot;&gt;&lt;code&gt;cargo c&lt;/code&gt; as an alias for &lt;code&gt;cargo check&lt;/code&gt;&lt;/a&gt;, and now &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6242/&quot;&gt;allows
usernames in registry URLs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-132.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-132.0&quot;&gt;&lt;/a&gt;Contributors to 1.32.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.32.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.32.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Procedural Macros in Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html" type="text/html" title="Procedural Macros in Rust 2018" />
        <published>2018-12-21T00:00:00Z</published>
        <updated>2018-12-21T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html">&lt;p&gt;Perhaps my favorite feature in the Rust 2018 edition is &lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html&quot;&gt;procedural macros&lt;/a&gt;.
Procedural macros have had a long and storied history in Rust (and will continue
to have a storied future!), and now is perhaps one of the best times to get
involved with them because the 2018 edition has so dramatically improved the
experience both defining and using them.&lt;/p&gt;
&lt;p&gt;Here I'd like to explore what procedural macros are, what they're capable of,
notable new features, and some fun use cases of procedural macros. I might even
convince you that this is Rust 2018's best feature as well!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-is-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-a-procedural-macro&quot;&gt;&lt;/a&gt;What is a procedural macro?&lt;/h3&gt;
&lt;p&gt;First defined over two years ago in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md&quot;&gt;RFC 1566&lt;/a&gt;, procedural macros are, in
layman's terms, a function that takes a piece of syntax at compile time and
produces a new bit of syntax. Procedural macros in Rust 2018 come in one of
three flavors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#[derive]&lt;/code&gt; mode macros&lt;/strong&gt; have actually been stable since &lt;a href=&quot;https://blog.rust-lang.org/2017/02/02/Rust-1.15.html&quot;&gt;Rust 1.15&lt;/a&gt;
and bring all the goodness and ease of use of &lt;code&gt;#[derive(Debug)]&lt;/code&gt; to
user-defined traits as well, such as &lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt;'s &lt;code&gt;#[derive(Deserialize)]&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Function-like macros&lt;/strong&gt; are newly stable to the 2018 edition and allow
defining macros like &lt;code&gt;env!(&amp;quot;FOO&amp;quot;)&lt;/code&gt; or &lt;code&gt;format_args!(&amp;quot;...&amp;quot;)&lt;/code&gt; in a
crates.io-based library. You can think of these as sort of &amp;quot;&lt;code&gt;macro_rules!&lt;/code&gt;
macros&amp;quot; on steroids.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Attribute macros&lt;/strong&gt;, my favorite, are also new in the 2018 edition
and allow you to provide lightweight annotations on Rust functions which
perform syntactical transformations over the code at compile time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these flavors of macros can be defined in a crate with &lt;code&gt;proc-macro = true&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/manifest.html&quot;&gt;specified in its manifest&lt;/a&gt;. When used, a procedural macro is
loaded by the Rust compiler and executed as the invocation is expanded. This
means that Cargo is in control of versioning for procedural macros and you can
use them with all same ease of use you'd expect from other Cargo dependencies!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#defining-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;defining-a-procedural-macro&quot;&gt;&lt;/a&gt;Defining a procedural macro&lt;/h3&gt;
&lt;p&gt;Each of the three types of procedural macros are &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/procedural-macros.html&quot;&gt;defined in a slightly different
fashion&lt;/a&gt;, and here we'll single out attribute macros. First, we'll flag
&lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[lib]
proc-macro = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then in &lt;code&gt;src/lib.rs&lt;/code&gt; we can write our macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then write some unit tests in &lt;code&gt;tests/smoke.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[my_crate::hello]
fn wrapped_function() {}

#[test]
fn works() {
    wrapped_function();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... and that's it! When we execute &lt;code&gt;cargo test&lt;/code&gt; Cargo will compile our
procedural macro. Afterwards it will compile our unit test which loads the macro
at compile time, executing the &lt;code&gt;hello&lt;/code&gt; function and compiling the resulting
syntax.&lt;/p&gt;
&lt;p&gt;Right off the bat we can see a few important properties of procedural macros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input/output is this fancy &lt;code&gt;TokenStream&lt;/code&gt; type we'll talk about more in a
bit&lt;/li&gt;
&lt;li&gt;We're &lt;em&gt;executing arbitrary code&lt;/em&gt; at compile time, which means we can do just
about anything!&lt;/li&gt;
&lt;li&gt;Procedural macros are incorporated with the module system, meaning they can
be imported just like any other name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we take a look at implementing a procedural macro, let's first dive into
some of these points.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#macros-and-the-module-system&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macros-and-the-module-system&quot;&gt;&lt;/a&gt;Macros and the module system&lt;/h3&gt;
&lt;p&gt;First stabilized in &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt; (noticing a trend with 1.15?) macros are now
integrated with the module system in Rust. This mainly means that you no longer
need the clunky &lt;code&gt;#[macro_use]&lt;/code&gt; attribute when importing macros! Instead of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate log;

fn main() {
    debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use log::info;

fn main() {
    log::debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Integration with the module system solves one of the most confusing parts about
macros historically. They're now imported and namespaced just as you would any
other item in Rust!&lt;/p&gt;
&lt;p&gt;The benefits are not only limited to bang-style &lt;code&gt;macro_rules&lt;/code&gt; macros, as you can
now transform code that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate serde_derive;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;into&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use serde::Deserialize;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you don't even need to explicitly depend on &lt;code&gt;serde_derive&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt;!
All you need is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
serde = { version = '1.0.82', features = ['derive'] }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#whats-inside-a-tokenstream?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-inside-a-tokenstream?&quot;&gt;&lt;/a&gt;What's inside a &lt;code&gt;TokenStream&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;This mysterious &lt;code&gt;TokenStream&lt;/code&gt; type comes from the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/&quot;&gt;compiler-provided
&lt;code&gt;proc_macro&lt;/code&gt; crate&lt;/a&gt;. When it was first added all you could do with a
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; was call convert it to or from a string using &lt;code&gt;to_string()&lt;/code&gt; or &lt;code&gt;parse()&lt;/code&gt;.
As of Rust 2018, you can act on the tokens in a &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; directly.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is effectively &amp;quot;just&amp;quot; an iterator over &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;. All
syntax in Rust falls into one of these four categories, the four variants of
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ident&lt;/code&gt; is any identifier like &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt;. This also contains keywords
such as &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Literal&lt;/code&gt; include things like &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, and &lt;code&gt;'b'&lt;/code&gt;. All literals are one
token and represent constant values in a program.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Punct&lt;/code&gt; represents some form of punctuation that's not a delimiter. For
example &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token in the field access of &lt;code&gt;foo.bar&lt;/code&gt;.
Multi-character punctuation like &lt;code&gt;=&amp;gt;&lt;/code&gt; is represented as two &lt;code&gt;Punct&lt;/code&gt; tokens,
one for &lt;code&gt;=&lt;/code&gt; and one for &lt;code&gt;&amp;gt;&lt;/code&gt;, and the &lt;code&gt;Spacing&lt;/code&gt; enum says that the &lt;code&gt;=&lt;/code&gt; is
adjacent to the &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Group&lt;/code&gt; is where the term &amp;quot;tree&amp;quot; is most relevant, as &lt;code&gt;Group&lt;/code&gt; represents a
delimited sub-token-stream. For example &lt;code&gt;(a, b)&lt;/code&gt; is a &lt;code&gt;Group&lt;/code&gt; with parentheses
as delimiters, and the internal token stream is &lt;code&gt;a, b&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this is conceptually simple, this may sound like there's not much we can
do with this! It's unclear, for example, how we might parse a function from a
&lt;code&gt;TokenStream&lt;/code&gt;. The minimality of &lt;code&gt;TokenTree&lt;/code&gt; is crucial, however, for
stabilization. It would be infeasible to stabilize the Rust AST because that
means we could never change it. (imagine if we couldn't have added the &lt;code&gt;?&lt;/code&gt;
operator!)&lt;/p&gt;
&lt;p&gt;By using &lt;code&gt;TokenStream&lt;/code&gt; to communicate with procedural macros, the compiler is
able to add new language syntax while also being able to compile
and work with older procedural macros. Let's see now, though, how we can
actually get useful information out of a &lt;code&gt;TokenStream&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#parsing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;parsing-a-tokenstream&quot;&gt;&lt;/a&gt;Parsing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;If &lt;code&gt;TokenStream&lt;/code&gt; is just a simple iterator, then we've got a long way to go from
that to an actual parsed function. Although the code is already lexed for us
we still need to write a whole Rust parser! Thankfully though the community has
been hard at work to make sure writing procedural macros in Rust is as smooth as
can be, so you need look no further than the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt; crate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate we can parse any Rust AST as a one-liner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;
    let abi = &amp;amp;input.abi;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate not only comes with the ability to parse built-in syntax
but you can also easily write a recursive descent parser for your own syntax.
The &lt;a href=&quot;https://docs.rs/syn/0.15/syn/parse/index.html&quot;&gt;&lt;code&gt;syn::parse&lt;/code&gt; module&lt;/a&gt; has more information about this capability.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#producing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;producing-a-tokenstream&quot;&gt;&lt;/a&gt;Producing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Not only do we take a &lt;code&gt;TokenStream&lt;/code&gt; as input with a procedural macro, but we
also need to produce a &lt;code&gt;TokenStream&lt;/code&gt; as output. This output is typically
required to be valid Rust syntax, but like the input it's just list of tokens
that we need to build somehow.&lt;/p&gt;
&lt;p&gt;Technically the only way to create a &lt;code&gt;TokenStream&lt;/code&gt; is via its &lt;code&gt;FromIterator&lt;/code&gt;
implementation, which means we'd have to create each token one-by-one and
collect it into a &lt;code&gt;TokenStream&lt;/code&gt;. This is quite tedious, though, so let's take a
look at &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;'s sibling crate: &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt; crate is a quasi-quoting implementation for Rust which primarily
provides a convenient macro for us to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use quote::quote;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;

    // Our input function is always equivalent to returning 42, right?
    let result = quote! {
        fn #name() -&amp;gt; u32 { 42 }
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/macro.quote.html&quot;&gt;&lt;code&gt;quote!&lt;/code&gt; macro&lt;/a&gt; allows you to write mostly-Rust syntax and interpolate
variables quickly from the environment with &lt;code&gt;#foo&lt;/code&gt;. This removes much of the
tedium of creating a &lt;code&gt;TokenStream&lt;/code&gt; token-by-token and allows quickly cobbling
together various pieces of syntax into one return value.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tokens-and-span&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tokens-and-span&quot;&gt;&lt;/a&gt;Tokens and &lt;code&gt;Span&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Perhaps the greatest feature of procedural macros in Rust 2018 is the ability to
customize and use &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; information on each token, giving us the ability for
amazing syntactical error messages from procedural macros:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: expected `fn`
 --&amp;gt; src/main.rs:3:14
  |
3 | my_annotate!(not_fn foo() {});
  |              ^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as well as completely custom error messages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: imported methods must have at least one argument
  --&amp;gt; invalid-imports.rs:12:5
   |
12 |     fn f1();
   |     ^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; can be thought of as a pointer back into an original source file,
typically saying something like &amp;quot;the &lt;code&gt;Ident&lt;/code&gt; token&lt;code&gt; foo&lt;/code&gt; came from file
&lt;code&gt;bar.rs&lt;/code&gt;, line 4, column 5, and was 3 bytes long&amp;quot;. This information is
primarily used by the compiler's diagnostics with warnings and error messages.&lt;/p&gt;
&lt;p&gt;In Rust 2018 each &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt; has a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; associated with it. This means that
if you preserve the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; of all input tokens into the output then even
though you're producing brand new syntax the compiler's error messages are still
accurate!&lt;/p&gt;
&lt;p&gt;For example, a small macro like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro]
pub fn make_pub(item: TokenStream) -&amp;gt; TokenStream {
    let result = quote! {
        pub #item
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when invoked as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;my_macro::make_pub! {
    static X: u32 = &amp;quot;foo&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is invalid because we're returning a string from a function that should return a
&lt;code&gt;u32&lt;/code&gt;, and the compiler will helpfully diagnose the problem as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0308]: mismatched types
 --&amp;gt; src/main.rs:1:37
  |
1 | my_macro::make_pub!(static X: u32 = &amp;quot;foo&amp;quot;);
  |                                     ^^^^^ expected u32, found reference
  |
  = note: expected type `u32`
             found type `&amp;amp;'static str`

error: aborting due to previous error

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see here that although we're generating brand new syntax, the
compiler can preserve span information to continue to provide targeted
diagnostics about code that we've written.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#procedural-macros-in-the-wild&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;procedural-macros-in-the-wild&quot;&gt;&lt;/a&gt;Procedural Macros in the Wild&lt;/h3&gt;
&lt;p&gt;Ok up to this point we've got a pretty good idea about what procedural macros
can do and the various capabilities they have in the 2018 edition. As such a
long-awaited feature, the ecosystem is already making use of these new
capabilities! If you're interested, some projects to keep your eyes on are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.rs/proc-macro2/0.4/proc_macro2/&quot;&gt;&lt;code&gt;proc-macro2&lt;/code&gt;&lt;/a&gt; are your go-to libraries for
writing procedural macros. They make it easy to define custom parsers, parse
existing syntax, create new syntax, work with older versions of Rust, and much
more!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt; and its derive macros for &lt;code&gt;Serialize&lt;/code&gt; and &lt;code&gt;Deserialize&lt;/code&gt; are likely the
most used macros in the ecosystem. They sport an &lt;a href=&quot;https://serde.rs/attributes.html&quot;&gt;impressive amount of
configuration&lt;/a&gt; and are a great example of how small annotations
can be so powerful.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rustwasm/wasm-bindgen&quot;&gt;&lt;code&gt;wasm-bindgen&lt;/code&gt; project&lt;/a&gt; uses attribute macros to easily define
interfaces in Rust and import interfaces from JS. The &lt;code&gt;#[wasm_bindgen]&lt;/code&gt;
lightweight annotation makes it easy to understand what's coming in and out,
as well as removing lots of conversion boilerplate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://gitlab.gnome.org/federico/gnome-class&quot;&gt;&lt;code&gt;gobject_gen!&lt;/code&gt; macro&lt;/a&gt; is an experimental IDL for the GNOME
project to define GObject objects safely in Rust, eschewing manually writing
all the glue necessary to talk to C and interface with other GObject
instances in Rust.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://rocket.rs/&quot;&gt;Rocket framework&lt;/a&gt; has recently switched over to procedural
macros, and showcases some of nightly-only features of procedural macros like
custom diagnostics, custom span creation, and more. Expect to see these
features stabilize in 2019!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's just a &lt;em&gt;taste&lt;/em&gt; of the power of procedural macros and some example usage
throughout the ecosystem today. We're only 6 weeks out from the original release
of procedural macros on stable, so we've surely only scratched the surface as
well! I'm really excited to see where we can take Rust with procedural macros by
empowering all kinds of lightweight additions and extensions to the language!&lt;/p&gt;
</content>

        <author>
            <name>Alex Crichton</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html" type="text/html" title="Announcing Rust 1.31.1" />
        <published>2018-12-20T00:00:00Z</published>
        <updated>2018-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.1. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1311-2018-12-20&quot;&gt;detailed release notes for
1.31.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.1-stable&quot;&gt;&lt;/a&gt;What's in 1.31.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes a build failure on &lt;code&gt;powerpc-unknown-netbsd&lt;/code&gt; by
way of &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56562&quot;&gt;an update to the &lt;code&gt;libc&lt;/code&gt;
crate&lt;/a&gt; used by the compiler.&lt;/p&gt;
&lt;p&gt;Additionally, the Rust Language Server was updated to fix two critical bugs.
First, &lt;a href=&quot;https://github.com/rust-lang/rls/pull/1170&quot;&gt;hovering over the type with documentation above single-line
attributes led to 100% CPU
usage:&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// Some documentation
#[derive(Debug)] // Multiple, single-line
#[allow(missing_docs)] // attributes
pub struct MyStruct { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rls/pull/1171&quot;&gt;Go to definition was fixed for std types&lt;/a&gt;:
Before, using the RLS on &lt;code&gt;HashMap&lt;/code&gt;, for example, tried to open this file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and now RLS goes to the correct location (for Rust 1.31, note the extra &lt;code&gt;src&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Tools in the 2018 edition</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html" type="text/html" title="Tools in the 2018 edition" />
        <published>2018-12-17T00:00:00Z</published>
        <updated>2018-12-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html">&lt;p&gt;Tooling is an important part of what makes a programming language practical and
productive. Rust has always had some great tools (Cargo in particular has a
well-deserved reputation as a best-in-class package manager and build tool), and
the 2018 edition includes more tools which we hope further improve Rust users'
experience.&lt;/p&gt;
&lt;p&gt;In this blog post I'll cover Clippy and Rustfmt – two tools that have been
around for a few years and are now stable and ready for general use. I'll also
cover IDE support – a key workflow for many users which is now much better
supported. I'll start by talking about Rustfix, a new tool which was central to
our edition migration plans.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rustfix&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rustfix&quot;&gt;&lt;/a&gt;Rustfix&lt;/h2&gt;
&lt;p&gt;Rustfix is a tool for automatically making changes to Rust code. It is a key
part of our migration story for the 2018 edition, making the transition from
2015 to 2018 editions much easier, and in many cases completely automatic. This
is essential, since without such a tool we'd be much more limited in the kinds
of breaking changes users would accept.&lt;/p&gt;
&lt;p&gt;A simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;trait Foo {
    fn foo(&amp;amp;self, i32);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above is legal in Rust 2015, but not in Rust 2018 (method arguments must be
made explicit). Rustfix changes the above code to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;trait Foo {
    fn foo(&amp;amp;self, _: i32);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For detailed information on how to use Rustfix, see &lt;a href=&quot;https://doc.rust-lang.org/stable/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html&quot;&gt;these instructions&lt;/a&gt;.
To transition your code from the 2015 to 2018 edition, run &lt;code&gt;cargo fix --edition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rustfix can do a lot, but it is not perfect. When it can't fix your code, it
will emit a warning informing you that you need to fix it manually. We're
continuing to work to improve things.&lt;/p&gt;
&lt;p&gt;Rustfix works by automatically applying suggestions from the compiler. When we
add or improve the compiler's suggestion for fixing an error or warning, then
that improves Rustfix. We use the same information in an IDE to give quick fixes
(such as automatically adding imports).&lt;/p&gt;
&lt;p&gt;Thank you to Pascal Hertleif (killercup), Oliver Scherer (oli-obk), Alex
Crichton, Zack Davis, and Eric Huss for developing Rustfix and the compiler
lints which it uses.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#clippy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;clippy&quot;&gt;&lt;/a&gt;Clippy&lt;/h2&gt;
&lt;p&gt;Clippy is a linter for Rust. It has numerous (currently 290!) lints to help
improve the correctness, performance and style of your programs. Each lint can
be turned on or off (&lt;code&gt;allow&lt;/code&gt;), and configured as either an error (&lt;code&gt;deny&lt;/code&gt;) or
warning (&lt;code&gt;warn&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;An example: the &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop&quot;&gt;&lt;code&gt;iter_next_loop&lt;/code&gt;&lt;/a&gt;
lint checks that you haven't made an error by iterating on the result of &lt;code&gt;next&lt;/code&gt;
rather than the object you're calling &lt;code&gt;next&lt;/code&gt; on (this is an easy mistake to make
when changing a &lt;code&gt;while let&lt;/code&gt; loop to a &lt;code&gt;for&lt;/code&gt; loop).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;for x in y.next() {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will give the error&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want
 --&amp;gt; src/main.rs:4:14
  |
4 |     for x in y.next() {
  |              ^^^^^^^^
  |
  = note: #[deny(clippy::iter_next_loop)] on by default
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clippy works by extending the Rust compiler. The compiler has support for a few
built-in lints, Clippy uses the same mechanisms but with lots more lints. That
means Clippy's error/warning format should be familiar, you should be able to
apply Clippy's suggestions in your IDE (or using Rustfix), and that the lints
are reliable and accurate.&lt;/p&gt;
&lt;p&gt;With Rust 1.31 and the 2018 edition, Clippy is available on stable Rust and has
backwards compatibility guarantees (if it had a version number, it would be
1.0). Clippy has the same stability guarantees as rustc: new lints may be added,
and lints may be modified to add more functionality, however lints may never be
removed (only deprecated). This means that code that compiles with Clippy will
continue to compile with Clippy (provided there are no lints set to error via
&lt;code&gt;deny&lt;/code&gt;), but may throw new warnings.&lt;/p&gt;
&lt;p&gt;Clippy can be installed using &lt;code&gt;rustup component add clippy&lt;/code&gt;, then use it with
&lt;code&gt;cargo clippy&lt;/code&gt;. For more information, including how to run it in your CI, see
&lt;a href=&quot;https://github.com/rust-lang/rust-clippy/&quot;&gt;the repo readme&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thank you Clippy team (Pascal Hertleif (killercup), Oliver Scherer (oli-obk),
Manish Goregaokar (manishearth), and Andre Bogus (llogiq))!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rustfmt&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rustfmt&quot;&gt;&lt;/a&gt;Rustfmt&lt;/h2&gt;
&lt;p&gt;Rustfmt is a tool for formatting your source code. It takes arbitrary, messy
code and turns it into neat, beautifully styled code.&lt;/p&gt;
&lt;p&gt;Automatically formatting saves you time and mental energy. You don't need to
worry about style as you code. If you use Rustfmt in your CI (&lt;code&gt;cargo fmt --check&lt;/code&gt;), then you don't need to worry about code style in review. By using a
standard style you make your project feel more familiar for new contributors and
spare yourself arguments about code style. Rust's &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md&quot;&gt;standard code
style&lt;/a&gt; is
the Rustfmt default, but if you must, then you can customize Rustfmt
extensively.&lt;/p&gt;
&lt;p&gt;Rustfmt 1.0 is part of the 2018 edition release. It should work on all code and
will be backwards compatible until the 2.0 release. By backwards compatible we
mean that if your code is formatted (i.e., excluding bugs which prevent any
formatting or code which does not compile), it will always be formatted in the
same way. This guarantee only applies if you use the default formatting options.&lt;/p&gt;
&lt;p&gt;Rustfmt is not done. Formatting is not perfect, in particular we don't touch
comments and string literals and we are pretty limited with macro definitions
and some macro uses. We're likely to improve formatting here, but you will need
to opt-in to these changes until there is a 2.0 release. We &lt;em&gt;are&lt;/em&gt; planning on
having a 2.0 release. Unlike Rust itself, we think its a good idea to have a
breaking release of Rustfmt and expect that to happen some time in late 2019.&lt;/p&gt;
&lt;p&gt;To install Rustfmt, use &lt;code&gt;rustup component add rustfmt&lt;/code&gt;. To format your project,
use &lt;code&gt;cargo fmt&lt;/code&gt;. You can also format individual files using &lt;code&gt;rustfmt&lt;/code&gt; (though
note that by default rustfmt will format nested modules). You can also use
Rustfmt in your editor or IDE using the RLS (see below; no need to install
rustfmt for this, it comes as part of the RLS). We recommend configuring your
editor to run rustfmt on save. Not having to think about formatting at all as
you type is a pleasant change.&lt;/p&gt;
&lt;p&gt;Thank you Seiichi Uchida (topecongiro), Marcus Klaas, and all the Rustfmt
contributors!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#ide-support&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;ide-support&quot;&gt;&lt;/a&gt;IDE support&lt;/h2&gt;
&lt;p&gt;For many users, their IDE is the most important tool. Rust IDE support has been
in the works for a while and is a highly demanded feature. Rust is now supported
in many IDEs and editors:
&lt;a href=&quot;https://plugins.jetbrains.com/plugin/8182-rust&quot;&gt;IntelliJ&lt;/a&gt;, &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio
Code&lt;/a&gt;,
&lt;a href=&quot;https://github.com/rust-lang-nursery/atom-ide-rust&quot;&gt;Atom&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/rust-enhanced&quot;&gt;Sublime
Text&lt;/a&gt;,
&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components&quot;&gt;Eclipse&lt;/a&gt;
(and more...). Follow each link for installation instructions.&lt;/p&gt;
&lt;p&gt;Editor support is powered in two different ways: IntelliJ uses its own compiler,
the other editors use the Rust compiler via the Rust Language Server (RLS). Both
approaches give a good but imperfect IDE experience. You should probably choose
based on which editor you prefer (although if your project does not use Cargo,
then you won't be able to use the RLS).&lt;/p&gt;
&lt;p&gt;All these editors come with support for standard IDE functions including 'go to
definition', 'find all references', code completion, renaming, and reformatting.&lt;/p&gt;
&lt;p&gt;The RLS has been developed by the Rust dev tools team, it is a bid to bring Rust
support to as many IDEs and editors as possible. It directly uses Cargo and the
Rust compiler to provide accurate information about a program. Due to
performance constraints, code completion is not yet powered by the compiler and
therefore can be a bit more hit and miss than other features.&lt;/p&gt;
&lt;p&gt;Thanks to the IDEs and editors team for work on the RLS and the various IDEs and
extensions (alexheretic, autozimu, jasonwilliams, LucasBullen, matklad,
vlad20012, Xanewok), Jonathan Turner for helping start off the RLS, and
phildawes, kngwyu, jwilm, and the other Racer contributors for their work on
Racer (the code completion component of the RLS)!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#the-future&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-future&quot;&gt;&lt;/a&gt;The future&lt;/h2&gt;
&lt;p&gt;We're not done yet! There's lots more we think we can do in the tools domain
over the next year or so.&lt;/p&gt;
&lt;p&gt;We've been improving rust debugging support in LLDB and GDB and there is more in
the works. We're experimenting with distributing our own versions with Rustup
and making debugging from your IDE easier and more powerful.&lt;/p&gt;
&lt;p&gt;We hope to make the RLS faster, more stable, and more accurate; including using
the compiler for code completion.&lt;/p&gt;
&lt;p&gt;We want to make Cargo a lot more powerful: Cargo will handle compiled binaries
as well as source code, which will make building and installing crates faster.
We will support better integration with other build systems (which in turn will
enable using the RLS with more projects). We'll add commands for adding and
upgrading dependencies, and to help with security audits.&lt;/p&gt;
&lt;p&gt;Rustdoc will see improvements to its source view (powered by the RLS) and links
between documentation for different crates.&lt;/p&gt;
&lt;p&gt;There's always lots of interesting things to work on. If you'd like to help chat
to us on GitHub or &lt;a href=&quot;https://discordapp.com/invite/rust-lang&quot;&gt;Discord&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Dev-tools team</name>
        </author>
    </entry>
    
    <entry>
        <title>A call for Rust 2019 Roadmap blog posts</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html" type="text/html" title="A call for Rust 2019 Roadmap blog posts" />
        <published>2018-12-06T00:00:00Z</published>
        <updated>2018-12-06T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html">&lt;p&gt;It's almost 2019! As such, the Rust team needs to create a roadmap for Rust's
development next year. At the highest level, Rust's development process looks
like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Rust community blogs about what they'd like to see.&lt;/li&gt;
&lt;li&gt;The core team reads these posts, and produces a &amp;quot;roadmap RFC,&amp;quot; a proposal
for what next year's development looks like.&lt;/li&gt;
&lt;li&gt;The RFC is widely discussed, and modified in response to feedback, and
eventually accepted.&lt;/li&gt;
&lt;li&gt;This RFC becomes a guideline for accepting or postponing RFCs for the next
year.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We try to align this with the calendar year, but it doesn't 100% match up,
currently. Last year, &lt;a href=&quot;https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html&quot;&gt;we had a call for posts on January
3&lt;/a&gt;,
the roadmap RFC was opened &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314&quot;&gt;on Jan
29th&lt;/a&gt;, and was &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314#issuecomment-370576889&quot;&gt;accepted on
March
5th&lt;/a&gt;.
This year, we're starting a bit earlier, but it's still not going to be
accepted before January 1.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#we-need-you&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;we-need-you&quot;&gt;&lt;/a&gt;We need you&lt;/h2&gt;
&lt;p&gt;Starting today and running until of January 15, we’d like to ask the
community to write blogposts reflecting on Rust in 2018 and proposing goals
and directions for Rust in 2019. Like last year, these can take many forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A post on your personal or company blog&lt;/li&gt;
&lt;li&gt;A Medium post&lt;/li&gt;
&lt;li&gt;A GitHub gist&lt;/li&gt;
&lt;li&gt;Or any other online writing platform you prefer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We’re looking for posts on many topics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ideas for community programs&lt;/li&gt;
&lt;li&gt;Language features&lt;/li&gt;
&lt;li&gt;Documentation improvements&lt;/li&gt;
&lt;li&gt;Ecosystem needs&lt;/li&gt;
&lt;li&gt;Tooling enhancements&lt;/li&gt;
&lt;li&gt;Or anything else Rust related you hope for in 2019&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's one additional thing this year, however. With the shipping of Rust
2018 today, it's time to think about the next edition. In other words:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust 2015: Stability&lt;/li&gt;
&lt;li&gt;Rust 2018: Productivity&lt;/li&gt;
&lt;li&gt;Rust 2021: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We aren't yet &lt;em&gt;committing&lt;/em&gt; to an edition in 2021, but that's the current
estimate. Each edition has had some sort of theme associated with it. As
such, we wouldn't just like to know what you're thinking for Rust in 2019,
but also, what you want the theme of Rust 2021 to be. Ideally, suggestions
for Rust in 2019 will fit into the overall goal of the next edition, though
of course, three years is a lot of time, and so not every single thing must.
As Rust matures, we need to start thinking of ever-longer horizons, and how
our current plans fit into those eventual plans.&lt;/p&gt;
&lt;p&gt;If you're not sure what to write, check out all of the blog posts from last
year &lt;a href=&quot;https://readrust.net/rust-2018/&quot;&gt;over at ReadRust&lt;/a&gt;. They may give you
some inspiration!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#please-share-these-posts-with-us&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;please-share-these-posts-with-us&quot;&gt;&lt;/a&gt;Please share these posts with us&lt;/h2&gt;
&lt;p&gt;You can write up these posts and email them to &lt;code&gt;community@rust-lang.org&lt;/code&gt; or
tweet them with the hashtag &lt;code&gt;#rust2019&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Core team will be reading all of the submitted posts and using them to
inform the initial roadmap RFC for 2019. Once the RFC is submitted, we’ll
open up the normal RFC process, though if you want, you are welcome to write
a post and link to it on the GitHub discussion.&lt;/p&gt;
&lt;p&gt;We look forward to working with the entire community to make Rust even more
wonderful in 2019. Thanks for an awesome 2018!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31 and Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html" type="text/html" title="Announcing Rust 1.31 and Rust 2018" />
        <published>2018-12-06T00:00:00Z</published>
        <updated>2018-12-06T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.0, and &amp;quot;Rust
2018&amp;quot; as well. Rust is a programming language that empowers everyone to build
reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes for
1.31.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.0-stable&quot;&gt;&lt;/a&gt;What's in 1.31.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.31 may be the most exciting release since Rust 1.0! Included in this release is the
first iteration of &amp;quot;Rust 2018,&amp;quot; but there's more than just that! This is going to be a long
post, so here's a table of contents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rust-2018&quot;&gt;Rust 2018&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot;&gt;Non-lexical lifetimes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#module-system-changes&quot;&gt;Module system changes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot;&gt;More lifetime elision rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#const-fn&quot;&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-tools&quot;&gt;New tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tool-lints&quot;&gt;Tool Lints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#documentation&quot;&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#domain-working-groups&quot;&gt;Domain working groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-website&quot;&gt;New website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#library-stabilizations&quot;&gt;Library stabilizations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cargo-features&quot;&gt;Cargo features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#contributors-to-131.0&quot;&gt;Contributors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#rust-2018&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-2018&quot;&gt;&lt;/a&gt;Rust 2018&lt;/h3&gt;
&lt;p&gt;We wrote about Rust 2018 &lt;a href=&quot;https://blog.rust-lang.org/2018/03/12/roadmap.html&quot;&gt;first in
March&lt;/a&gt;, &lt;a href=&quot;https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html&quot;&gt;and then in
July&lt;/a&gt;.
For some more background about the &lt;em&gt;why&lt;/em&gt; of Rust 2018, please go read those
posts; there's a lot to cover in the release announcement, and so we're going
to focus on the &lt;em&gt;what&lt;/em&gt; here. There's also a &lt;a href=&quot;https://hacks.mozilla.org/2018/12/rust-2018-is-here/&quot;&gt;post on Mozilla Hacks&lt;/a&gt; as
well!&lt;/p&gt;
&lt;p&gt;Briefly, Rust 2018 is an opportunity to bring
all of the work we've been doing over the past three years together, and create
a cohesive package. This is more than just language features, it also includes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tooling (IDE support, &lt;code&gt;rustfmt&lt;/code&gt;, Clippy)&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;li&gt;Domain working groups work&lt;/li&gt;
&lt;li&gt;A new web site&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be covering all of this and more in this post.&lt;/p&gt;
&lt;p&gt;Let's create a new project with Cargo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cargo new foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here's the contents of &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[package]
name = &amp;quot;foo&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Your Name &amp;lt;you@example.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[dependencies]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new key has been added under &lt;code&gt;[package]&lt;/code&gt;: &lt;code&gt;edition&lt;/code&gt;. Note that it has been
set to &lt;code&gt;2018&lt;/code&gt;. You can also set it to &lt;code&gt;2015&lt;/code&gt;, which is the default if the key
does not exist.&lt;/p&gt;
&lt;p&gt;By using Rust 2018, some new features are unlocked that are not allowed in
Rust 2015.&lt;/p&gt;
&lt;p&gt;It is important to note that each package can be in either 2015 or
2018 mode, and they work seamlessly together. Your 2018 project can use 2015
dependencies, and a 2015 project can use 2018 dependencies. This ensures that
we don't split the ecosystem, and all of these new things are opt-in,
preserving compatibility for existing code. Furthermore, when you do choose
to migrate Rust 2015 code to Rust 2018, the changes can be made
automatically, via &lt;code&gt;cargo fix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What kind of new features, you may ask? Well, first, features get added to
Rust 2015 unless they require some sort of incompatibility with 2015's
features. As such, most of the language is available everywhere. You can
check out &lt;a href=&quot;https://doc.rust-lang.org/edition-guide&quot;&gt;the edition
guide&lt;/a&gt; to check each
feature's minimum &lt;code&gt;rustc&lt;/code&gt; version as well as edition requirements. However,
there are a few big-ticket features we'd like to mention here: non-lexical
lifetimes, and some module system improvements.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;non-lexical-lifetimes&quot;&gt;&lt;/a&gt;Non-lexical lifetimes&lt;/h4&gt;
&lt;p&gt;If you've been following Rust's development over the past few years, you may
have heard the term &amp;quot;NLL&amp;quot; or &amp;quot;non-lexical lifetimes&amp;quot; thrown around. This is
jargon, but it has a straightforward translation into simpler terms: the
borrow checker has gotten smarter, and now accepts some valid code that it
previously rejected. Consider this example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;

    let y = &amp;amp;x;

    let z = &amp;amp;mut x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In older Rust, this is a compile-time error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because lifetimes follow &amp;quot;lexical scope&amp;quot;; that is, the borrow from &lt;code&gt;y&lt;/code&gt;
is considered to be held until &lt;code&gt;y&lt;/code&gt; goes out of scope at the end of main, even
though we never use &lt;code&gt;y&lt;/code&gt; again. This code is fine, but the borrow checker could
not handle it.&lt;/p&gt;
&lt;p&gt;Today, this code will compile just fine.&lt;/p&gt;
&lt;p&gt;What if we did use &lt;code&gt;y&lt;/code&gt;, like this for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;
    let y = &amp;amp;x;
    let z = &amp;amp;mut x;
    
    println!(&amp;quot;y: {}&amp;quot;, y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Older Rust will give you this error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With Rust 2018, this error changes for the better:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:13
  |
4 |     let y = &amp;amp;x;
  |             -- immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |     
7 |     println!(&amp;quot;y: {}&amp;quot;, y);
  |                       - borrow later used here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of pointing to where &lt;code&gt;y&lt;/code&gt; goes out of scope, it shows you where the
conflicting borrow occurs. This makes these sorts of errors far easier to
debug.&lt;/p&gt;
&lt;p&gt;In Rust 1.31, this feature is exclusive to Rust 2018. We plan to backport it
to Rust 2015 at a later date.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#module-system-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;module-system-changes&quot;&gt;&lt;/a&gt;Module system changes&lt;/h4&gt;
&lt;p&gt;The module system can be a struggle for people first learning Rust.
Everyone has their own things that take time to master, of course, but
there's a root cause for why it's so confusing to many: while there are
simple and consistent rules defining the module system, their consequences
can feel inconsistent, counterintuitive and mysterious.&lt;/p&gt;
&lt;p&gt;As such, the 2018 edition of Rust introduces a few changes to how paths work,
but they end up simplifying the module system, to make it more clear as to
what is going on.&lt;/p&gt;
&lt;p&gt;Here's a brief summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern crate&lt;/code&gt; is no longer needed in almost all circumstances.&lt;/li&gt;
&lt;li&gt;You can import macros with &lt;code&gt;use&lt;/code&gt;, rather than a &lt;code&gt;#[macro_use]&lt;/code&gt; attribute.&lt;/li&gt;
&lt;li&gt;Absolute paths begin with a crate name, where the keyword &lt;code&gt;crate&lt;/code&gt; refers to the current crate.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;foo.rs&lt;/code&gt; and &lt;code&gt;foo/&lt;/code&gt; subdirectory may coexist; &lt;code&gt;mod.rs&lt;/code&gt; is no longer needed when placing submodules in a subdirectory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall.&lt;/p&gt;
&lt;p&gt;There's a &lt;em&gt;lot&lt;/em&gt; of details here, so please read &lt;a href=&quot;https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html&quot;&gt;the edition
guide&lt;/a&gt;
for full details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;more-lifetime-elision-rules&quot;&gt;&lt;/a&gt;More lifetime elision rules&lt;/h3&gt;
&lt;p&gt;Let's talk about a feature that's available in both editions: we've added
some additional elision rules for &lt;code&gt;impl&lt;/code&gt; blocks and function definitions.
Code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl&amp;lt;'a&amp;gt; Reader for BufReader&amp;lt;'a&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;can now be written like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl Reader for BufReader&amp;lt;'_&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;'_&lt;/code&gt; lifetime still shows that &lt;code&gt;BufReader&lt;/code&gt; takes a parameter, but we
don't need to create a name for it anymore.&lt;/p&gt;
&lt;p&gt;Lifetimes are still required to be defined in structs. However, we no longer
require as much boilerplate as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// Rust 2015
struct Ref&amp;lt;'a, T: 'a&amp;gt; {
    field: &amp;amp;'a T
}

// Rust 2018
struct Ref&amp;lt;'a, T&amp;gt; {
    field: &amp;amp;'a T
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;: 'a&lt;/code&gt; is inferred. You can still be explicit if you prefer. We're
considering some more options for elision here in the future, but have no
concrete plans yet.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;There's several ways to define a function in Rust: a regular function with
&lt;code&gt;fn&lt;/code&gt;, an unsafe function with &lt;code&gt;unsafe fn&lt;/code&gt;, an external function with &lt;code&gt;extern fn&lt;/code&gt;.
This release adds a new way to qualify a function: &lt;code&gt;const fn&lt;/code&gt;. It looks like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn foo(x: i32) -&amp;gt; i32 {
    x + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;const fn&lt;/code&gt; can be called like a regular function, but it can also be used
in any constant context. When it is, it is evaluated at compile time, rather
than at run time. As an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const SIX: i32 = foo(5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will execute &lt;code&gt;foo&lt;/code&gt; at compile time, and set &lt;code&gt;SIX&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const fn&lt;/code&gt;s cannot do everything that normal &lt;code&gt;fn&lt;/code&gt;s can do; they must
have deterministic output. This is important for soundness reasons.
Currently, &lt;code&gt;const fn&lt;/code&gt;s can do a minimal subset of operations. Here's
some examples of what you can do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arithmetic and comparison operators on integers&lt;/li&gt;
&lt;li&gt;All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Constructing arrays, structs, enums, and tuples&lt;/li&gt;
&lt;li&gt;Calls to other &lt;code&gt;const fn&lt;/code&gt;s&lt;/li&gt;
&lt;li&gt;Index expressions on arrays and slices&lt;/li&gt;
&lt;li&gt;Field accesses on structs and tuples&lt;/li&gt;
&lt;li&gt;Reading from constants (but not statics, not even taking a reference to a static)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; of references&lt;/li&gt;
&lt;li&gt;Casts, except for raw pointer to integer casts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be growing the abilities of &lt;code&gt;const fn&lt;/code&gt;, but we've decided that
this is enough useful stuff to start shipping the feature itself.&lt;/p&gt;
&lt;p&gt;For full details, please see &lt;a href=&quot;https://doc.rust-lang.org/reference/items/functions.html#const-functions&quot;&gt;the
reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-tools&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-tools&quot;&gt;&lt;/a&gt;New tools&lt;/h3&gt;
&lt;p&gt;The 2018 edition signals a new level of maturity for Rust's tools ecosystem.
Cargo, Rustdoc, and Rustup have been crucial tools since 1.0; with the 2018
edition, there is a new generation of tools ready for all users: Clippy,
Rustfmt, and IDE support.&lt;/p&gt;
&lt;p&gt;Rust's linter, &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/&quot;&gt;&lt;code&gt;clippy&lt;/code&gt;&lt;/a&gt;, is
now available on stable Rust. You can install it via &lt;code&gt;rustup component add clippy&lt;/code&gt; and run it with &lt;code&gt;cargo clippy&lt;/code&gt;. Clippy is now considered 1.0, which
carries the same lint stability guarantees as rustc. New lints may be added,
and lints may be modified to add more functionality, however lints may never
be removed (only deprecated). This means that code that compiles under clippy
will continue to compile under clippy (provided there are no lints set to
error via &lt;code&gt;deny&lt;/code&gt;), but may throw new warnings.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rustfmt&quot;&gt;Rustfmt&lt;/a&gt; is a tool for formatting Rust
code. Automatically formatting your code lets you save time and arguments by
using the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md&quot;&gt;official Rust
style&lt;/a&gt;.
You can install with &lt;code&gt;rustup component add rustfmt&lt;/code&gt; and use it with &lt;code&gt;cargo fmt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This release includes Rustfmt 1.0. From now on we guarantee backwards
compatibility for Rustfmt: if you can format your code today, then the
formatting will not change in the future (only with the default options).
Backwards compatibility means that running Rustfmt on your CI is practical
(use &lt;code&gt;cargo fmt -- --check&lt;/code&gt;). Try that and 'format on save' in your editor to
revolutionize your workflow.&lt;/p&gt;
&lt;p&gt;IDE support is one of the most requested tooling features for Rust. There are
now multiple, high quality options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/8182-rust&quot;&gt;IntelliJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang-nursery/atom-ide-rust&quot;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust-enhanced&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components&quot;&gt;Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Work on IDE support is not finished, in particular code completion is not up
to scratch in the RLS-based editors. However, if you mainly want support for
types, documentation, and 'go to def', etc. then you should be happy.&lt;/p&gt;
&lt;p&gt;If you have problems installing any of the tools with Rustup, try running
&lt;code&gt;rustup self update&lt;/code&gt;, and then try again.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tool-lints&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tool-lints&quot;&gt;&lt;/a&gt;Tool lints&lt;/h3&gt;
&lt;p&gt;In &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt;, we
stabilized &amp;quot;tool attributes&amp;quot;, like &lt;code&gt;#[rustfmt::skip]&lt;/code&gt;. In Rust 1.31, we're
stabilizing something similar: &amp;quot;tool lints,&amp;quot; like
&lt;code&gt;#[allow(clippy::bool_comparison)]&lt;/code&gt; These give a namespace to lints, so that it's
more clear which tool they're coming from.&lt;/p&gt;
&lt;p&gt;If you previously used Clippy's lints, you can migrate like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// old
#![cfg_attr(feature = &amp;quot;cargo-clippy&amp;quot;, allow(bool_comparison))]

// new
#![allow(clippy::bool_comparison)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don't need &lt;code&gt;cfg_attr&lt;/code&gt; anymore! You'll also get warnings that can help you
update to the new style.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#documentation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;documentation&quot;&gt;&lt;/a&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Rustdoc has seen a number of improvements this year, and we also shipped a
complete re-write of the &amp;quot;The Rust Programming Language.&amp;quot; Additionally, you
can &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;buy a dead-tree copy from No Starch Press&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We had previously called this the &amp;quot;second edition&amp;quot; of the book, but since
it's the first edition in print, that was confusing. We also want to
periodically update the print edition as well. In the end, after many
discussions with No Starch, we're going to be updating the book on the
website with each release, and No Starch will periodically pull in our
changes and print them. The book has been selling quite well so far, raising
money for &lt;a href=&quot;http://www.blackgirlscode.com/&quot;&gt;Black Girls Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can find the new TRPL &lt;a href=&quot;https://doc.rust-lang.org/beta/book/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#domain-working-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;domain-working-groups&quot;&gt;&lt;/a&gt;Domain working groups&lt;/h3&gt;
&lt;p&gt;We announced the formation of four working groups this year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services&lt;/li&gt;
&lt;li&gt;Command-line applications&lt;/li&gt;
&lt;li&gt;WebAssembly&lt;/li&gt;
&lt;li&gt;Embedded devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these groups has been working very hard on a number of things to
make Rust awesome in each of these domains. Some highlights:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services has been shaking out the Futures interface, and async/await
on top of it. This hasn't shipped yet, but we're close!&lt;/li&gt;
&lt;li&gt;The CLI working group has been working on libraries and documentation for making awesome
command-line applications&lt;/li&gt;
&lt;li&gt;The WebAssembly group has been shipping a ton of world-class tooling for using Rust with wasm.&lt;/li&gt;
&lt;li&gt;Embedded devices has gotten ARM development working on stable Rust!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find out more about this work on the new website!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-website&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-website&quot;&gt;&lt;/a&gt;New Website&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html&quot;&gt;Last
week&lt;/a&gt;
we announced a new iteration of the web site. It's now been promoted to
rust-lang.org itself!&lt;/p&gt;
&lt;p&gt;There's still a ton of work to do, but we're proud of the year of work that it
took by many people to get it shipped.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;A bunch of &lt;code&gt;From&lt;/code&gt; implementations have been added:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u8&lt;/code&gt; now implements &lt;code&gt;From&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt;, and likewise for the other numeric types and their &lt;code&gt;NonZero&lt;/code&gt; equivalents&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;From&amp;lt;&amp;amp;Option&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, and likewise for &lt;code&gt;&amp;amp;mut&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these functions have been stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.align_to&quot;&gt;&lt;code&gt;slice::align_to&lt;/code&gt;&lt;/a&gt; and its mutable counterpart&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact&quot;&gt;&lt;code&gt;slice::chunks_exact&lt;/code&gt;&lt;/a&gt;,
as well as its mutable and &lt;code&gt;r&lt;/code&gt; counterparts (like
&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut&quot;&gt;&lt;code&gt;slice::rchunks_exact_mut&lt;/code&gt;&lt;/a&gt;) in all combinations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo will now download packages in parallel using HTTP/2.&lt;/p&gt;
&lt;p&gt;Additionally, now that &lt;code&gt;extern crate&lt;/code&gt; is not usually required, it would be
jarring to do &lt;code&gt;extern crate foo as baz;&lt;/code&gt; to rename a crate. As such, you can
do so in your &lt;code&gt;Cargo.toml&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
baz = { version = &amp;quot;0.1&amp;quot;, package = &amp;quot;foo&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, the equivalent&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies.baz]
version = &amp;quot;0.1&amp;quot;
package = &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the &lt;code&gt;foo&lt;/code&gt; package will be able to be used via &lt;code&gt;baz&lt;/code&gt; in your code.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-131.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-131.0&quot;&gt;&lt;/a&gt;Contributors to 1.31.0&lt;/h2&gt;
&lt;p&gt;At the end of release posts, we normally thank &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.31.0&quot;&gt;the people who contributed to
this release&lt;/a&gt;. But for this
release, more so than others, this list does not truly capture the amount of
work and the number of people who have contributed. Each release is only six
weeks, but this release is the culmination of three years of effort, in
countless repositories, by numerous people. It's been a pleasure to work with
you all, and we look forward to continuing to grow in the next three years.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>A new look for rust-lang.org</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html" type="text/html" title="A new look for rust-lang.org" />
        <published>2018-11-29T00:00:00Z</published>
        <updated>2018-11-29T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html">&lt;p&gt;Before 1.0, Rust had a reputation for changing the language on a near-daily
basis. By contrast, the website has looked pretty much the same. Here’s the
first version of rust-lang.org, seven years ago (courtesy of &lt;a href=&quot;https://web.archive.org/&quot;&gt;the WayBack
Machine&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www1.png&quot; alt=&quot;rust website in 2011&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In 2014, three years later:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www2.png&quot; alt=&quot;rust website in 2014&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If you visit &lt;a href=&quot;https://rust-lang.org&quot;&gt;https://rust-lang.org&lt;/a&gt; today, you'll see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www3.png&quot; alt=&quot;rust website in 2018&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Over time, we’ve grown to love it. It’s simple. Minimal. Familiar.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#improving-the-content&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improving-the-content&quot;&gt;&lt;/a&gt;Improving the content&lt;/h2&gt;
&lt;p&gt;But we can always do better. For example, the website suffers from what we
call “the fireflower problem.” First formulated by &lt;a href=&quot;http://seriouspony.com/&quot;&gt;Kathy
Sierra&lt;/a&gt;, and made into an image by Samuel Hulick:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/fireflower.png&quot; alt=&quot;the fireflower&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We want Mario to use Rust, the fireflower, and turn into the ever-awesome
Fire Mario. But there’s a corollary here: it’s better to say “we will make
you into Fire Mario” than it is “we sell fire flowers.”&lt;/p&gt;
&lt;p&gt;(As an aside, we had a &lt;a href=&quot;https://brson.github.io/fireflowers/&quot;&gt;community discussion on this
topic&lt;/a&gt; back in 2016.)&lt;/p&gt;
&lt;p&gt;In other words, this list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zero-cost abstractions&lt;/li&gt;
&lt;li&gt;move semantics&lt;/li&gt;
&lt;li&gt;guaranteed memory safety&lt;/li&gt;
&lt;li&gt;threads without data races&lt;/li&gt;
&lt;li&gt;trait-based generics&lt;/li&gt;
&lt;li&gt;pattern matching&lt;/li&gt;
&lt;li&gt;type inference&lt;/li&gt;
&lt;li&gt;minimal runtime&lt;/li&gt;
&lt;li&gt;efficient C bindings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;doesn’t explain what you can &lt;em&gt;do&lt;/em&gt; with Rust, which leads people to say “Rust
seems neat, but I don’t know what I would actually use it for.”&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#improving-the-style&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improving-the-style&quot;&gt;&lt;/a&gt;Improving the style&lt;/h2&gt;
&lt;p&gt;We also like the minimalist style of the current site, but it also may be
&lt;em&gt;too&lt;/em&gt; minimal. Furthermore, it has no room to grow; we have more than just
rust-lang.org these days. We wanted a style that we could use to unify all of
the websites that we maintain in the Rust project; crates.io being a big one.
Its “pool table” design feels extremely different than rust-lang.org, which
is confusing.&lt;/p&gt;
&lt;p&gt;Doing this requires care, as we don’t want to make the website huge and
complicated, but at the same time, using more than black and blue might be
nice.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#the-beta&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-beta&quot;&gt;&lt;/a&gt;The beta&lt;/h2&gt;
&lt;p&gt;Today, we’d like to announce a beta of the new rust-lang.org. If you go to
&lt;a href=&quot;https://beta.rust-lang.org&quot;&gt;https://beta.rust-lang.org&lt;/a&gt;, you’ll see this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rust-www4.png&quot; alt=&quot;beta rust website&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Its fresh visual design gives us a lot more flexibility in how we get
information across. It retains the minimalist spirit of the old site, while
adding some bold color and visual variety.&lt;/p&gt;
&lt;p&gt;We hope you like it as much as we do!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#some-highlights&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;some-highlights&quot;&gt;&lt;/a&gt;Some highlights&lt;/h3&gt;
&lt;p&gt;The new site puts the “why Rust?” question front-and-center, and includes
dedicated pages for the four application domains we targeted in 2018:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Embedded devices&lt;/li&gt;
&lt;li&gt;WebAssembly&lt;/li&gt;
&lt;li&gt;CLI apps&lt;/li&gt;
&lt;li&gt;Network services&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have also revised the slogan. Historically, it has been:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rust is a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Like the bullet list of features, this doesn't convey what you can &lt;em&gt;do&lt;/em&gt; with
Rust. So we've updated the slogan:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rust: The programming language that empowers everyone to become a systems
programmer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We're still not sure we love the term &amp;quot;systems programming,&amp;quot; as it seems like
it means something different to everyone, but this iteration is significantly
better than the old one. Even if people have different ideas about what
&amp;quot;systems programming&amp;quot; means, they at least have some idea. &amp;quot;guarantees thread
safety,&amp;quot; not so much.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#future-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;future-work&quot;&gt;&lt;/a&gt;Future work&lt;/h2&gt;
&lt;p&gt;There’s still more work to do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some information on the old site, has not yet been ported over.&lt;/li&gt;
&lt;li&gt;Translations have regressed. We’re working on adding the proper
infrastructure here, and hope to be able to start accepting translations by
the end of the year.&lt;/li&gt;
&lt;li&gt;We need more polish and testing in a general sense.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please &lt;a href=&quot;https://github.com/rust-lang/beta.rust-lang.org/issues/new/choose&quot;&gt;file an
issue&lt;/a&gt; with any
feedback you have! We’re also looking for people with abilities of all kinds
to help maintain the site, and especially people with design, CSS, and
marketing skills. If you’d like to get involved, please &lt;a href=&quot;mailto:www@rust-lang.org&quot;&gt;email
us&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We’d like to ship this new site on December 6, with the release of Rust 2018.
Thank you for giving it a try before then, so we can work out any bugs we
find!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Survey 2018 Results</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html" type="text/html" title="Rust Survey 2018 Results" />
        <published>2018-11-27T00:00:00Z</published>
        <updated>2018-11-27T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html">&lt;p&gt;Another year means another Rust survey, and this year marks Rust's third annual survey. This year, the survey launched for the first time in multiple languages. In total &lt;strong&gt;14&lt;/strong&gt; languages, in addition to English, were covered.  The results from non-English languages totalled &lt;em&gt;25% of all responses&lt;/em&gt; and helped pushed the number of responses to a new record of &lt;strong&gt;5991 responses&lt;/strong&gt;. Before we begin the analysis, we just want to give a big &amp;quot;thank you!&amp;quot; to all the people who took the time to respond and give us your thoughts. It’s because of your help that Rust will continue to improve year after year.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/1-Do_you_use_Rust.png&quot; alt=&quot;Do you use Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Despite having an increase in the number of responses, this year also saw an increase in the percentage of Rust users. Up from last year’s 66.9% Rust users, this year nearly three-quarters of responses were from Rust users.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#rust-users&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-users&quot;&gt;&lt;/a&gt;Rust Users&lt;/h1&gt;
&lt;h2&gt;&lt;a href=&quot;#time-with-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;time-with-rust&quot;&gt;&lt;/a&gt;&lt;strong&gt;Time with Rust&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/4-How_long_have_you_worked_in_Rust.png&quot; alt=&quot;How long have you worked in Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’re seeing a steady stream of new users into Rust. At the time of the survey, ~23% of Rust users had been using it for 3 months or less.  Likewise, nearly a quarter of the users have used Rust for at least 2 years.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/5-How_long_did_it_take_to_be_productive.png&quot; alt=&quot;How long did it take to be productive&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Over 40% of Rust users felt productive in Rust in less than a month of use, and over 70% felt productive in their first year. Unfortunately, there is a noticeable struggle among users, as over 22% do not yet feel productive.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/5a-How_long_have_you_been_unproductive.png&quot; alt=&quot;How long have you been unproductive&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Looking closer at these users who feel unproductive in Rust, only about 25% are in their first month of use. The challenge here is to find ways to help bridge users to productivity so they don't get stuck.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#how-much-do-you-use-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-much-do-you-use-rust&quot;&gt;&lt;/a&gt;&lt;strong&gt;How much do you use Rust?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/6-Size_of_summed_Rust_projects.png&quot; alt=&quot;Size of summed Rust projects&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust projects are continuing to trend to larger sizes, with larger overall investments. Medium to large investments in Rust (those totally over 10k and 100k lines of code respectively) have grown from 8.9% in 2016, to 16% in 2017, to &lt;strong&gt;23%&lt;/strong&gt; this year.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/7-How_often_use_Rust.png&quot; alt=&quot;How often do you use Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’ve also seen a growth in Rust regular usage. Up from 17.5% last year, Rust daily usage is now nearly a quarter of users. In total, Rust weekly total usage has risen from 60.8% to 66.4%.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-expertise&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-expertise&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust expertise&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/8-How_you_rate_your_Rust_expertise.png&quot; alt=&quot;How would you rate your Rust expertise&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rather than being a simple curve, Rust expertise has two peaks: one around a &amp;quot;3&amp;quot;, and another at &amp;quot;7&amp;quot;, showing that users tend to see themselves as just above beginner or experienced without necessarily being expert.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/9-How_difficult_are_Rust_concepts.png&quot; alt=&quot;How difficult are Rust concepts&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust users generally felt that Enums and Cargo were largely easy concepts; followed by Iterators, Modules, and Traits. More challenging concepts of Trait Bounds and Unsafe came next. Lastly, the most challenging concepts were Macros, Ownership &amp;amp; Borrowing, and Lifetimes. These challenges match closely to feedback we’ve heard in years past and continue to be a focus of continued productivity improvements like NLL and the continued macro system improvements.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/22-Programming_language_familiarity.png&quot; alt=&quot;What programming languages are you familiar with&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Humorously, we see that Rust isn't actually the top programming language that users were familiar with. Instead, it pulled in a 2nd place behind Python.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-toolchain&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-toolchain&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust toolchain&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/10-Which_Rust_version.png&quot; alt=&quot;Which Rust version do you use&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We’re seeing similar numbers in users of the current stable release since last year. Perhaps surprisingly, we’re continuing to see a rise in the number of users who use the Nightly compiler in their workflow. For the second year in a row, Nightly usage has continued to rise, and is now over 56% (up from 51.6% of last year).&lt;/p&gt;
&lt;p&gt;When asked why they used nightly, people responded with a broad range of reasons including: access to 2018 edition, asm, async/await, clippy, embedded development, rocket, NLL, proc macros, and wasm.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/11-Has_upgrading_compiler_broken_you.png&quot; alt=&quot;Has upgrading the compiler broken your code&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The percentage of people who see a breakage during a routine compiler update has stayed the same since last year, with 7.4% saying they’ve experienced breakage.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/12-If_so_how_much_work_to_fix.png&quot; alt=&quot;If so how much work to fix it&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Breakages generally leaned to requiring minor fixes, though some reported having moderate or major fixes to upgrade to the next stable compiler.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/13-Preferred_install_method.png&quot; alt=&quot;Preferred install method&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We again see a strong showing for &lt;code&gt;rustup&lt;/code&gt;, which continues to hold at 90% of Rust installs. Linux distros follow as a distant second at 17%.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/14-Tool-experience.png&quot; alt=&quot;Experience with Rust tools&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Tools like &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;rustdoc&lt;/code&gt; had a strong show, with lots of positive support.  Following these is the &lt;code&gt;clippy&lt;/code&gt; tool -- despite having fewer users, its users enjoy the tool.  The IDE support tools &lt;code&gt;Rust Language Server&lt;/code&gt; and &lt;code&gt;racer&lt;/code&gt; had positive support but unfortunately, of the tools surveyed, generated a few more dislike votes and comments. The &lt;code&gt;bindgen&lt;/code&gt; tool has relatively small userbase.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-workflow&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-workflow&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust workflow&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/15-Platform_developing_on.png&quot; alt=&quot;Which platform are you developing on&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Linux continues to be a powerhouse among Rust developers, holding on to roughly 80% of Rust developers.  Windows usage has grown slightly from 31% last year to 34% this year, its second year in a row of growth.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/16-Platforms_targeting.png&quot; alt=&quot;Which platforms are you developing for&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Linux and Windows continued to show strongly as targets for Rust applications. Other platforms held largely the same as last year, with one exception: WebAssembly. The new technology has showed impressive growth, nearly doubling from last year's 13% to this year's 24%.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/17-Editors.png&quot; alt=&quot;What editors do you use&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Vim, the front-runner in editors for two years has now finally been bested by VSCode, which grew from 33.8% of Rust developers to 44.4% this year.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-at-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-at-work&quot;&gt;&lt;/a&gt;&lt;strong&gt;Rust at work&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/18-Rust_at_work.png&quot; alt=&quot;Do you use Rust at work&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Rust continues is slow-and-steady growth in the workplace. We're now seeing year-over-year growth of full-time and part-time Rust, growing from last year's 4.4% full-time and 16.6% part-time to this year's &lt;strong&gt;8.9% full-time&lt;/strong&gt; and &lt;strong&gt;21.2% part-time&lt;/strong&gt;, a doubling of full-time Rust commercial use.  In total, Rust commercial use grew from 21% to just over 30% of Rust users.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/19-Company_evaluate_Rust.png&quot; alt=&quot;Is your company evaluating Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There is more room for Rust to grow into more companies, over a third of which users report aren't currently looking into evaluating Rust in the coming year.  When paired with the survey data that said that nearly half of non-users needed the company support, this shows the need for further company outreach or more company-focused information about Rust.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#feeling-welcome&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;feeling-welcome&quot;&gt;&lt;/a&gt;&lt;strong&gt;Feeling welcome&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/23-Do_you_feel_welcome.png&quot; alt=&quot;Do you feel welcome in the Rust community&quot; /&gt;&lt;/p&gt;
&lt;p&gt;An important part of the Rust community efforts are ensuring that the Rust project is a welcoming place for its users. New users should feel encouraged to explore, share ideas, and generally be themselves.&lt;/p&gt;
&lt;p&gt;When asked, both current Rust users and non-users largely felt welcome, though over a quarter of responses weren't sure.  There was also some regional variation in these responses.  For example, responses on the Russian version of the survey showed double the percent of unwelcome feelings at 4%. Mainland China showed even more at 8%.&lt;/p&gt;
&lt;p&gt;There's a challenge here to help Rust communities worldwide feel like they are part of what makes Rust unique, as Rust continues to grow a strong presence in more areas of the world.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/24-Underrepresented.png&quot; alt=&quot;Are you underrepresented in tech&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The number of people in Rust who self-identify as being part of a group underrepresented in technology is growing slowly year-over-year. The survey also highlights some challenges, as the number of women is still lower than the industry average of women in programming fields.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#rust-non-users&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-non-users&quot;&gt;&lt;/a&gt;Rust Non-Users&lt;/h1&gt;
&lt;p&gt;A big part of a welcoming Rust community is reaching out to non-users as well. As we have in years past, we again asked the reasons why people weren't using Rust.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/2-How_long_before_you_stopped.png&quot; alt=&quot;How long before you stopped&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For those who stopped using Rust, just over 50% stopped using Rust in less than a month. Likewise, roughly 50% of people who left Rust managed to use it for more than a month before stopping.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018-11-RustSurvey/3-Why_not_using_Rust.png&quot; alt=&quot;Why are you not using Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Many non-users responded that they did want to learn Rust, but there were factors that slowed them down. First among these is that the companies the responders work for do not themselves use Rust. Nearly one half of the non-users were blocked by the lack of company support.&lt;/p&gt;
&lt;p&gt;Additionally, 1 in 4 non-users were slowed by the feeling of Rust being too intimidating or complicated. The work towards improving Rust IDE support has helped (down from 25% to 16%), though we still see a strong push towards even better IDE support among non-users.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#challenges&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;challenges&quot;&gt;&lt;/a&gt;Challenges&lt;/h1&gt;
&lt;p&gt;As we've done in past years, we asked for your comments in where Rust can improve. This year, we see some familiar themes as well as some new ones in this feedback. The top ten themes this year are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the need for better library support&lt;/li&gt;
&lt;li&gt;a more improved IDE experience&lt;/li&gt;
&lt;li&gt;the need for broader adoption of Rust generally&lt;/li&gt;
&lt;li&gt;a richer ecosystem of tools and support&lt;/li&gt;
&lt;li&gt;an improved learning curve&lt;/li&gt;
&lt;li&gt;the need for important language features and crates to be stable and supported&lt;/li&gt;
&lt;li&gt;support for async programming&lt;/li&gt;
&lt;li&gt;support for GUI development&lt;/li&gt;
&lt;li&gt;better documentation&lt;/li&gt;
&lt;li&gt;improved compile times&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;New this year is the rising need to &lt;strong&gt;support GUI development&lt;/strong&gt;, showing that Rust continues to grow not only on the server, but that people are feeling the need to stretch into application development.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Improve Rust marketing. Many people don't know about it&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Comments remind us that while Rust may be well-known in some circles, it still has room to grow and in many tech circles Rust may not yet be well-known.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Keeping a focus on adoption/tutorials/books/novice experience will pay dividends in the years to come.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In addition to outreach, a broader set of documentation would in turn help reach a broader audience.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Stability and maturity of developer tools, make it easier to get a working setup and to debug applications&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Many people commented on the IDE support, pointing out not only instability or inaccuracy in the RLS, but also the need for a much stronger IDE story that covered more areas, like easier debugging.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;The maturity of the ecosystem and libraries. Have a good ecosystem of &amp;quot;standard&amp;quot; libraries is key for the future of the language&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A common theme continues to be the need to push libraries to completion and grow the set of &amp;quot;standard&amp;quot; libraries that users can use. Some comments point out this isn't the fault of maintainers, who are already working hard to write and publish the crates, but that generally more companies need to get involved and offer commercial support.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Ergonomics and discoverability of &amp;quot;putting it together&amp;quot; documentation&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some people pointed out that ergonomics goes hand in hand with richer documentation, seeing that these aren't separate concepts but rather challenges that should be tackled together in a unified approach.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#looking-forward&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;looking-forward&quot;&gt;&lt;/a&gt;Looking forward&lt;/h2&gt;
&lt;p&gt;This year saw the strongest survey yet. Not only was it the largest community survey, it was the first to cover languages outside of English. Rust continues to grow steadily, and with it, both its strengths and challenges are introduced to a broader audience.&lt;/p&gt;
&lt;p&gt;We look forward to using your feedback in planning for 2019, and we're excited to see where we can take Rust next.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Team</name>
        </author>
    </entry>
    
</feed>